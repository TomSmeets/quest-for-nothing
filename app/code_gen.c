// Copyright (c) 2023 - Tom Smeets <tom@tsmeets.nl>
// code_gen.c - Generate C code for this project
//
// The generated code should be code I would have written myself.
// Things this could do are:
// - Enum to String
// - Automatically add typedefs
// - ... that is all?

// Current timings, N=2048
//   O0 -> 5.3 ms
//   O2 -> 3.3 ms
#include "fmt.h"
#include "os_generic.h"
#include "parse.h"

struct gen_enum {
    const char *name;
    const char *values;
};

// Return the pointer to the beginning of the next line, or null if we reach eof
char *next_line(char *l) {
    for(;;) {
        char c = *l;
        if(c == 0)    return l;
        if(c == '\n') return l+1;
        l++;
    }
}

static void fmt_keys(fmt_t *f) {
    for(u32 i = 0; i <= 9; ++i) {
        fmt_f(f, "KEY_%d,\n", i);
    }

    for(u32 i = 'A'; i <= 'Z'; ++i) {
        fmt_f(f, "KEY_%c,\n", i);
    }
}

static bool tok_is_op(Token *tok, char *op) {
    return tok->type == Token_Op && str_eq(tok->str, op);
}

static bool tok_is_symbol(Token *tok, char *sym) {
    return tok->type == Token_Symbol && str_eq(tok->str, sym);
}

static void handle_file(fmt_t *f, mem *m, char *path) {
    char *file = os_read_file(m, path).ptr;
    Token *tok = parse_token(m, file);
    assert(file);

    // for(Token *t = tok;t;t = t->next)
    //     os_printf("// tok: %s\n", t->str);

    bool new_statement = 0;
    while(tok) {
        if(new_statement && (tok_is_symbol(tok, "struct") || tok_is_symbol(tok, "union")) && tok->next && tok->next->next && tok_is_op(tok->next->next, "{")) {
            char *kind = tok->str;
            tok = tok->next;
            char *name = tok->str;
            fmt_f(f, "typedef %s %s %s;\n", kind, name, name);
        }

        if(new_statement && tok_is_symbol(tok, "enum")) {
            tok = tok->next;

            char *name = tok->str;
            fmt_f(f, "static const char * const enum_to_str_%s[] = {\n", name);

            tok = tok->next; // {
            assert(tok_is_op(tok, "{"));

            while(tok && !tok_is_op(tok, "}")) {
                if(tok->type == Token_Symbol) {
                    fmt_f(f, "    \"%s\",\n", tok->str);
                }
                tok = tok->next;
            }
            fmt_str(f, "};\n");
        }

        new_statement = tok_is_op(tok, "}") || tok_is_op(tok, ";") || tok->type == Token_Macro;
        tok = tok->next;
    }
}

static void handle_dir(fmt_t *f, mem *m, char *dir) {
    for(os_dir *d = os_read_dir(m, dir); d; d = d->next) {
        if(!d->is_file) continue;
        char *path = fmt(m, "%s/%s", dir, d->file_name);
        // fmt_f(f, "// ==== %s ====\n", path);
        handle_file(f, m, path);
    }
}

// Convert the data to a
static void c_encode(fmt_t *f, char *name, buf data) {
    fmt_str(f, "#define ");
    fmt_str(f, name);
    fmt_str(f, "_SIZE ");
    fmt_u64(f, data.size, 10, 0, 0, 0);
    fmt_str(f, "\n");
    fmt_str(f, "static const unsigned char ");
    fmt_str(f, name);
    fmt_str(f, "_DATA[] = {");
    for(u64 i = 0; i < data.size + 1; ++i) {
        if(i % 16 == 0) fmt_str(f, "\n    ");
        u8 b = ((u8 *) data.ptr)[i];
        fmt_u64(f, b, 10, 0, 0, 0);
        fmt_str(f, ",");
    }
    fmt_str(f, "\n};\n");
}

void *main_init(int argc, char *argv[]) {
    mem m = {};
    fmt_t f = { .mem = &m};
    fmt_str(&f, "// Copyright (c) 2023 - Tom Smeets <tom@tsmeets.nl>\n");
    fmt_str(&f, "// generated.h - This file is generated by " __FILE__ "\n");
    fmt_str(&f, "#pragma once\n");
    handle_dir(&f, &m, "src");
    handle_dir(&f, &m, "app");

    c_encode(&f, "GL_SHADER_VERT", os_read_file(&m, "src/gl_shader.vert"));
    c_encode(&f, "GL_SHADER_FRAG", os_read_file(&m, "src/gl_shader.frag"));
    os_print(fmt_end(&f));
    return 0;
}

void main_update(void *handle) { os_exit(0); }
