#pragma once
#include "build/clang.h"
#include "build/cli.h"
#include "build/hot.h"
#include "build/include_graph.h"
#include "build/watch.h"
#include "lib/fmt.h"

// Read command line options for build targets
static bool build_read_opts(Cli *cli, Clang_Options *opts) {
    opts->input_path = cli_value(cli, "<Input>", "Source Input Path");
    if (!opts->input_path) return false;

    opts->output_path = cli_value(cli, "<Output>", "Execurtable Output Path");
    if (!opts->output_path) return false;

    while (cli_read(cli)) {
        if (0) {
        } else if (cli_flag(cli, "linux", "Compile for Linux")) {
            opts->platform = Platform_Linux;
        } else if (cli_flag(cli, "windows", "Compile for Windows")) {
            opts->platform = Platform_Windows;
        } else if (cli_flag(cli, "wasm", "Compile for Webassembly")) {
            opts->platform = Platform_Wasm;
        } else if (cli_flag(cli, "release", "Compile in Release Mode")) {
            opts->release = true;
        } else if (cli_flag(cli, "dynamic", "Create a dynamic executable (a .dll/.so file)")) {
            opts->dynamic = true;
        } else {
            return false;
        }
    }
    return true;
}

#define TYPEDEF_STRUCT(NAME) typedef struct NAME NAME;

TYPEDEF_STRUCT(Build);
TYPEDEF_STRUCT(Build_Source);

// Source paths
struct Build_Source {
    String path;
    Build_Source *next;
};

struct Build {
    // Source directories
    Build_Source *sources;

    // Dit a source file change on disk?
    Watch watch;
    bool changed;
};

static Build *build_new(void) {
    Build *build = mem_struct(G->mem, Build);
    build->changed = true;
    return build;
}

static void build_add_source(Build *build, String path) {
    Build_Source *src = mem_struct(G->mem, Build_Source);
    src->path = path;
    LIST_PUSH(build->sources, src, next);
    watch_add(&build->watch, str_c(path));
}

// Code formatter option
// Returns true if the argument is matched
static bool build_format(Build *build, Cli *cli) {
    if (!cli_flag(cli, "format", "Run code formatter")) return false;

    Fmt *cmd = fmt_memory(G->tmp);
    fmt_s(cmd, "clang-format --verbose -i --");
    fmt_s(cmd, " $(find");
    for (Build_Source *src = build->sources; src; src = src->next) {
        fmt_str(cmd, S(" "));
        fmt_str(cmd, src->path);
    }
    fmt_s(cmd, " -name '*.h' -o -name '*.c'");
    fmt_s(cmd, ")");
    fmt_s(G->fmt, "Running Command: ");
    fmt_str(G->fmt, fmt_get(cmd));
    fmt_s(G->fmt, "\n");
    bool result = os_system(fmt_get(cmd));
    assert(result, "Format failed!");
    os_exit(0);
    return true;
}

static bool build_serve(Build *build, Cli *cli) {
    if (!cli_flag(cli, "serve", "Start a simple local python http server for testing wasm builds")) return false;
    assert(os_system(S("cd out && python -m http.server")), "Failed to start python http server. Is python installed?");
    os_exit(0);
    return true;
}

static bool build_build(Build *app, Cli *cli) {
    bool build = cli_flag(cli, "build", "Build an executable");
    bool watch = cli_flag(cli, "watch", "Build an executable and watch changes");
    if (!build && !watch) return false;
    if (watch && !app->changed) return true;

    Clang_Options opts = {};
    if (!build_read_opts(cli, &opts)) {
        cli_show_usage(cli, G->fmt);
        os_exit(1);
    }

    bool ret = clang_compile(opts);
    if (build) os_exit(ret ? 0 : 1);
    return true;
}

static void build_generate_clangd(Build *build) {
    Fmt *fmt = fmt_open(G->tmp, ".clangd");
    fmt_s(fmt, "# Generated by 'build.h'\n");
    fmt_s(fmt, "CompileFlags:\n");
    fmt_s(fmt, "  Add: [\n");
    fmt_s(fmt, "    -xc,\n");
    fmt_s(fmt, "    -Wall,\n");
    fmt_s(fmt, "    -Wextra,\n");
    fmt_s(fmt, "    -Wno-unused-function,\n");
    fmt_s(fmt, "    -std=c23,\n");

    u32 buf_size = 1024;
    char *cwd = mem_push_uninit(G->tmp, buf_size);
    linux_getcwd(cwd, buf_size);

    for (Build_Source *src = build->sources; src; src = src->next) {
        fmt_s(fmt, "    ");
        fmt_s(fmt, "-I");
        fmt_s(fmt, cwd);
        fmt_s(fmt, "/");
        fmt_str(fmt, src->path);
        fmt_s(fmt, ",\n");

        fmt_s(fmt, "    ");
        fmt_s(fmt, "--embed-dir=");
        fmt_s(fmt, cwd);
        fmt_s(fmt, "/");
        fmt_str(fmt, src->path);
        fmt_s(fmt, ",\n");
    }
    fmt_s(fmt, "  ]\n");
    fmt_s(fmt, "  Compiler: clang\n");
    fmt_close(fmt);
}

static bool build_opt_clangd(Build *build, Cli *cli) {
    bool doit = cli_flag(cli, "clangd", "Generate .clangd based on current project root and settings");
    if (!doit) return false;
    build_generate_clangd(build);
    os_exit(0);
    return true;
}

static void build_update(Build *build) {
    build->changed = watch_check(&build->watch);
}
